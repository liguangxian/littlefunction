 Heap tuple header.  To avoid wasting space, the fields should be  laid out in such a way as to avoid structure padding.   Datums of composite types (row types) share the same general structure  as on-disk tuples, so that the same routines can be used to build and  examine them.  However the requirements are slightly different: a Datum  does not need any transaction visibility information, and it does need  a length word and some embedded type information.  We can achieve this  by overlaying the xmin/cmin/xmax/cmax/xvac fields of a heap tuple  with the fields needed in the Datum case.  Typically, all tuples built  in-memory will be initialized with the Datum fields; but when a tuple is  about to be inserted in a table, the transaction fields will be filled,  overwriting the datum fields.   The overall structure of a heap tuple looks like: 			fixed fields (HeapTupleHeaderData struct) 			nulls bitmap (if HEAP_HASNULL is set in t_infomask) 			alignment padding (as needed to make user data MAXALIGN'd) 			object ID (if HEAP_HASOID is set in t_infomask) 			user data fields   We store five "virtual" fields Xmin, Cmin, Xmax, Cmax, and Xvac in three  physical fields.  Xmin and Xmax are always really stored, but Cmin, Cmax  and Xvac share a field.  This works because we know that Cmin and Cmax  are only interesting for the lifetime of the inserting and deleting  transaction respectively.  If a tuple is inserted and deleted in the same  transaction, we store a "combo" command id that can be mapped to the real  cmin and cmax, but only by use of local state within the originating  backend.  See combocid.c for more details.  Meanwhile, Xvac is only set by  old-style VACUUM FULL, which does not have any command sub-structure and so  does not need either Cmin or Cmax.  (This requires that old-style VACUUM  FULL never try to move a tuple whose Cmin or Cmax is still interesting,  ie, an insert-in-progress or delete-in-progress tuple.)   A word about t_ctid: whenever a new tuple is stored on disk, its t_ctid  is initialized with its own TID (location).  If the tuple is ever updated,  its t_ctid is changed to point to the replacement version of the tuple.  Thus, a tuple is the latest version of its row iff XMAX is invalid or  t_ctid points to itself (in which case, if XMAX is valid, the tuple is  either locked or deleted).  One can follow the chain of t_ctid links  to find the newest version of the row.  Beware however that VACUUM might  erase the pointed-to (newer) tuple before erasing the pointing (older)  tuple.  Hence, when following a t_ctid link, it is necessary to check  to see if the referenced slot is empty or contains an unrelated tuple.  Check that the referenced tuple has XMIN equal to the referencing tuple's  XMAX to verify that it is actually the descendant version and not an  unrelated tuple stored into a slot recently freed by VACUUM.  If either  check fails, one may assume that there is no live descendant version.   t_ctid is sometimes used to store a speculative insertion token, instead  of a real TID.  A speculative token is set on a tuple that's being  inserted, until the inserter is sure that it wants to go ahead with the  insertion.  Hence a token should only be seen on a tuple with an XMAX  that's still in-progress, or invalid/aborted.  The token is replaced with  the tuple's real TID when the insertion is confirmed.  One should never  see a speculative insertion token while following a chain of t_ctid links,  because they are not used on updates, only insertions.   Following the fixed header fields, the nulls bitmap is stored (beginning  at t_bits).  The bitmap is not stored if t_infomask shows that there  are no nulls in the tuple.  If an OID field is present (as indicated by  t_infomask), then it is stored just before the user data, which begins at  the offset shown by t_hoff.  Note that t_hoff must be a multiple of  MAXALIGN.